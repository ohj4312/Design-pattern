# 디자인 패턴

## 디자인 패턴의 이해

### 디자인 패턴이란

- 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 **고질적인 문제**들이 또 발생했을 때 **재사용** 할 수 있는 훌륭한 해결책 → 이미 훌륭한 프로그래머가 고민하고 해결해 놓은 방법들을 사용하는 것
- 이름을 부여해 하나의 시스템을 디자인할 때 공통 언어 역할을 하게 되어 좀 더 효율적으로 **협동 작업**을 할 수 있게 됨
- 패턴 : 비슷하거나 동일한 양식 또는 유형들이 반복되어 나타난다는 의미. 서로 간에 공통되는 설계 문제를 처리하는 해결책들의 유사점 → 공통의 언어를 만들어 의사 소통을 원할하게 함

### 디자인 패턴의 구성요소

1. 콘텍스트(context)
    - 문제가 발생하는 여러 가지 **상황**을 기술 → 패턴이 적용될 수 있는 상황
    - 경우에 따라서는 패턴이 유용하지 못한 상황을 나타내기도 함
2. 문제(problem)
    - 패턴이 적용되어 해결될 필요가 있는 여러 디자인 **이슈**들
3. 해결(solution)
    - **문제를 해결하도록** 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계를 기술
    - 다양한 상황에 적용할 수 있는 일종의 템플릿

ex) 싱글톤의 경우

- context : 클래스가 객체를 생성하는 과정을 제어해야 하는 상황
- problem : 애플리케이션이 전역적으로 접근하고 관리할 필요가 있는 데이터를 포함한다. 동시에 이러한 데이터는 시스템에 유일하다. 어떤 방식으로 클래스에서 생성되는 객체의 수를 제어하고 클래스의 인터페이스에 접근하는 것을 제어해야 하는가?
- solution : 클래스의 생성자를 public으로 정의하지 말고 private나 protected로 선언해 외부에서 생성자를 이용해 객체를 일단 생성할 수 없게 만들고... → 싱글톤 패턴을 사용하자

### 구분

- 아키텍처 패턴(전체 틀느낌?)
    - 시스템을 구성하는 컴포넌트의 구성과 컴포넌트 사이의 협조 방법을 패턴화
    - 레이어 패턴, 파이프&필터, 브로커 패턴 등
- 디자인 패턴
    - 아키텍처 패턴에서 컴포넌트의 **내부 구조**를 대상으로 한 클래스/객체의 구조와 협업 방법을 패턴화 한 것
- 관용구
    - 각각의 프로그램 언어 특유의 패턴, 프로그래밍에서 자주 사용하는 기술 방법(코딩 방법)을 패턴화

<br>

## GoF 디자인 패턴

### GoF란

- GoF(Gang of Four) : 소프트웨어 개발 영역에서 디자인패턴을 구체화하고 체계화한 사람들
- 디자인 패턴을 24가지로 정리하고, 생성, 구조, 행위의 3가지로 분류

### GoF 디자인 패턴의 분류

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2aeddb09-6805-469c-aa64-c55572386435/Untitled.png)

1. 생성 패턴(creational)
    - 객체 생성에 관련된 패턴
    - 객체의 생성과 조합을 캠슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공
2. 구조 패턴(structural)
    - 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
    - ex) 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공, 객체들을 서로 묶어 새로운 기능을 제공
3. 행위 패턴(behavioral)
    - 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
    - ex) 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점

<br>

## UML과 디자인 패턴

### UML

- 컬레보레이션(collaboration)
    - UML 2.0에서 디자인 패턴을 표현하는 도구
    - 컬레보레이션을 통해 디자인 패턴을 정확하게 표현하려면 구조적인 면과 행위적인 면을 모두 표현할 필요가 있음
    - 구조적인 면 : 어떤 요소들이 주어진 목적을 달성하기 위해 협력하는지 → 어떤객체들이 있는지?
    - 행위적인 면 :  협력을 위한 요소들의 상호작용 → 어떤 관계가 있는지?

### 컬레보레이션

- 한 객체는 여러 역할을 수행할 수 있음
- UML에서 객체들이 특정 상황에서 수행하는 역할의 상호작용을 작성 → 객체가 수행하는 역할들의 협력을 표현해줌, 역할들의 상호작용을 추상화함
- 표기법
    - 점선으로 된 타원 기호 사용
    - 타원 내부에 협력을 필요로 하는 **역할**들과 그들 사이의 **연결 관계**를 표현
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ea48c93-11f3-4cdf-aa74-77c5b9e5a7ad/Untitled.png)
    
    - 상황 - 담보 대출 / 역할 - 대출자, 대출인, 담보
- 컬레보레이션 어커런스(collaboration occurrence)
    - 더 구체적인 상황에서의 컬레보레이션 적용을 표현해줌(추상적인 개념을 실제 상황에 적용)
    - ex) 은행집담보대출 - 담보대출의 한 예이며 컬레보레이션 어커런스임

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ec339e5-7aa0-4f82-9c36-3916ef2caff9/Untitled.png)

- 대출자 - 은행
- 대출인 - 사람
- 담보 - 집

### 순차 다이어그램(Sequence Diagram)

- UML 2.0에서 객체들의 상호작용을 나타내는 다이어그램 중 하나(행위적인 면을 모델링)
- 객체들 사이의 **메시지 송신**과 그들의 **순서**를 나타냄.
- 가능한 **한 시나리오**에 관한 객체 사이의 상호작용을 보여주는 데 사용되어야 함

### 순차 다이어그램 표기법

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1ed6787-f429-4f38-bb33-42cb2aa86506/Untitled.png)

- 객체 표현 표기법 - '객체이름:클래스이름'(양쪽 모두 생략 가능)
- 생명선 - 객체 아래로 가는 점선 → 해당 객체가 존재함을 보여줌
- 활성 구간 - 객체가 연산을 실행하는 상태임을 보여줌 → 생략 가능
- 화살표 - 객체 사이의 메시지
    - 비동기 메시지(asynchronous) - 열려 있는 화살표 → 메시지를 송신한 후 메시지 실행이 끝나기를 기다리지 않고 다음 작업을 바로 수행 가능
    - 동기 메시지(synchronous) - 머리 부분이 채워진 화살표 → 메시지의 실행을 요청하는 객체는 메시지의 실행이 종료될 때까지 다음 작업을 수행할 수 없음
    - 자체 메시지 - 결과로 생성된 실행 발생이 전송 실행 위에 나타남
    - 응답 메시지 - 점선 화살표 → 생략 가능
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9f0438e6-9a8a-4b83-89e0-b35c3642817c/Untitled.png)
    
- 메시지
    - 형식 : [시퀸스 번호][가드] : 반환 값 := 메시지 이름([인자 리스트]) → 메시지 이름을 제외하고 모두 생략 가능
    - 가드 - 메시지가 송신되는 데 만족해야 하는 조건
    - <<create>> - 객체 생성
    - <<destroy>> - 객체 소멸, 소멸되는 객체의 생명선 끝에 'x'를 넣음
- 프레임 - UML 2.0에서 제공
    - sd로 표시
    - 다이어그램의 경계, 타입, 이름을 포함한 레이블의 장소를 제공
    - 다이어그램을 에워싸는 박스로 표시하며 왼쪽 모서리에 다이어그램의 타입과 이름을 넣음
    - 다이어그램 외부에서 특정 다이어그램을 참조하는 것이 쉬움
- ref 키워드
    - 다른 순차 다이어그램을 참조함
    - 상호작용의 일부분이 다른 곳에서 재사용되거나, 순차 다이어그램으로 매우 복잡한 상호작용을 모델링하는 경우에는 하나의 순차 다이어그램에서 모든 상호 작용을 표현하지 않고 분리해 작성한 후 이를 참조할 수 있게 하는 편이 좋음 → 이 때 사용
- alt 키워드
    - 조건문 → 선택적으로 수행 할 수 있도록
- loop 키워드
    - 반복적인 상호작용을 나타냄
- opt : 특정 조건에서만 상호작용을 선택적으로 수행
- par : 동시에 실행되는 상호작용을 수행
- break : 특정 상호작용 그룹을 빠져나갈 때 사용

### 순차 다이어그램과 클래스 다이어그램의 관계

- 순차 다이어그램 : 객체 사이의 메시지 흐름과 순서를 알려주는 행위 측면에 중점을 두는 모델(**상호작용**)
- 클래스 다이어그램 : 시스템의 **구조적인** 측면에 중점을 두는 모델

→ 의미적 차이는 있지만 두 다이어그램은 밀접한 관계가 있으며 이들을 이용해 시스템을 모델링할 때 서로 정합이 이루어져야 함

ex) 순차 다이어그램에서 클래스 x의 인스턴스가 y의 인스턴스에게 메시지를 보낼 때, 두 클래스는 연관 또는 의존 관계가 존재함 

- 연관관계(협력 느낌... - 필드) vs 의존관계(일시적인 느낌... - 매개변수, 인자)
- 어떤 관계를 사용해야 하는가? 구현 직전의 모델이라면 이를 구분해 처리하는 것이 좋음
    1. x가 y에게 한번의 메시지만을 송신한다면 y는 이후에 필요 없음 → 의존 관계
    2. x가 y에게 여러 번의 메시지를 송신한다면 클래스 다이어그램 관점에서 x는 y를 기억할 필요가 있으므로 장기적 관계를 형성함 → 연관 관계

∴ 하지만 순차 다이어그램 하나는 하나의 시나리오만을 표현하므로 이렇게 모델링하는 것이 적합하지 않을 수 있음